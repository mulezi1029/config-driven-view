# 统一配置协议设计

在**不改变现有功能与语义**的前提下，定义一套「统一子节点形式」的配置协议，使整棵树可由单一递归逻辑遍历（类似 Vue 对虚拟 DOM 树的递归），而不必在各容器内按 type 分支取子。

---

## 一、设计目标

- **统一子节点形式**：凡有子节点的节点，子节点一律出现在同一字段（`children`），且该字段为**节点数组**（每项均为带 `type` 的配置对象），不再出现「字符串与对象混用」「单值 content」「二维 rows」等异构形态。
- **保持现有语义**：section 的折叠、list 的有序/无序、table 的表头与单元格、note 的图标与单块等行为不变；仅调整**数据形状**，不改变**表现与能力**。
- **可自递归**：渲染器只需实现「取当前节点的 `children`（若存在）并逐项递归渲染」，无需按 type 分支「子从 content/items/rows 取」。

---

## 二、核心约定

### 2.1 节点（Node）

- 每个节点为**普通对象**，**必须**包含 `type`（字符串），用于组件映射与递归时的类型判断。
- 除根节点外，任意节点均可选包含 **`children`**。
- **`children` 的约定**：
  - 若存在，则**必为数组**；
  - 数组元素**仅能为节点对象**（即带 `type` 的对象），**不得**为裸字符串或数字；
  - 无子节点时可不写 `children`，或写 `children: []`。

即：所有「有子」的节点都用 `children: [ node, node, ... ]` 表示，不再使用 `content`/`items`/`rows`/单值 `content` 等异构字段表示子节点。

### 2.2 根配置（Root）

根仍保留 `version`、`metadata`、`styles`，顶层内容统一用 **`children`** 表示（与现有 `content` 等价，仅字段名统一为 `children`）：

| 字段       | 类型   | 必填 | 说明 |
|------------|--------|------|------|
| version    | string | 建议 | 文档版本 |
| metadata   | object | 否   | title、lastUpdated、author 等 |
| styles     | object | 否   | 与现有一致 |
| **children** | array  | 是   | 顶层块级节点数组（替代原 `content`） |

---

## 三、各 type 在统一协议下的形态

以下在**不改变现有组件语义**的前提下，把当前「子从哪里来、长什么样」映射到统一的 `children` 形式。

### 3.1 叶子节点（无子）

以下类型**无** `children`（或 `children: []`），保留现有字段即可：

| type        | 保留字段与语义 |
|-------------|----------------|
| heading     | level, content（标题文本） |
| paragraph   | content |
| styledText  | content, style? |
| richText    | content（HTML 字符串） |
| image       | src, alt?, width?, height?, caption? |
| link        | href, content, target?, rel? |
| divider     | 无额外字段 |

### 3.2 容器节点（有子 → 统一为 children）

#### section

- **现有**：`title?`, `content: [ 块级 config, ... ]`
- **统一**：`title?`, **`children`**：数组，每项为块级节点。
- 语义不变：折叠标题用 `title`，内容区渲染 `children` 中每一项。

```json
{
  "type": "section",
  "title": "1. 协议的接受",
  "children": [
    { "type": "paragraph", "content": "通过访问或使用……" },
    { "type": "list", "style": "ordered", "children": [ … ] }
  ]
}
```

#### list

- **现有**：`style: 'ordered'|'unordered'`, `items: (string | 块级 config)[]`
- **统一**：`style` 不变，**`children`**：数组，每项为**节点**；原「纯字符串」项用 **`text`** 节点表示。
- 语义不变：根用 `<ol>`/`<ul>`，每项包在 `<li>` 内，对每项递归渲染（text 渲染为纯文本）。

**约定**：新增节点类型 **`text`**，表示一段纯文本，仅含 `type: 'text'` 与 `content: string`。

```json
{
  "type": "list",
  "style": "ordered",
  "children": [
    { "type": "text", "content": "您必须年满18周岁才能使用我们的服务。" },
    { "type": "text", "content": "您需要提供真实、准确的个人信息。" },
    { "type": "styledText", "style": "highlight", "content": "您不得将我们的服务用于任何非法目的。" }
  ]
}
```

#### table

- **现有**：`headers: string[]`, `rows: (string | 块级 config)[][]`，可选 `columnAlignments`
- **统一**：表头仍为 `headers: string[]`（表头不递归）；表体用 **`children`** 表示**行**，每行为一个 **`tableRow`** 节点；每个 `tableRow` 的 **`children`** 表示该行单元格（每个单元格为一个节点，纯文本用 `text` 节点）。
- 语义不变：表头一行、表体每行一行，单元格内可仍为文本或复杂块。

**约定**：新增节点类型 **`tableRow`**，仅作为表格行的容器，含 **`children`**（单元格节点数组）。表格本身不直接存「二维数组」，而是「行的数组」，每行再带「单元格的数组」，从而全部用 `children` 表达。

```json
{
  "type": "table",
  "headers": ["服务类型", "描述", "收费标准"],
  "columnAlignments": ["left", "left", "right"],
  "children": [
    {
      "type": "tableRow",
      "children": [
        { "type": "text", "content": "基础服务" },
        { "type": "text", "content": "提供基本功能访问" },
        { "type": "text", "content": "免费" }
      ]
    },
    {
      "type": "tableRow",
      "children": [
        { "type": "text", "content": "高级服务" },
        { "type": "text", "content": "提供高级功能和额外支持" },
        { "type": "text", "content": "每月$9.99" }
      ]
    }
  ]
}
```

若某单元格为块级（如图片、段落），则对应位置为 `{ type: 'image', ... }` 等节点即可。

#### note

- **现有**：`content: string | 块级 config`，`icon?`
- **统一**：`icon?` 不变，**`children`**：长度为 0 或 1 的数组；原字符串用 `{ type: 'text', content }`，原对象即该唯一子节点。
- 语义不变：note 仍只展示一段文字或一个子块。

```json
{ "type": "note", "icon": "ℹ️", "children": [{ "type": "text", "content": "我们可能会不时调整……" }] }
{ "type": "note", "children": [{ "type": "paragraph", "content": "内嵌段落" }] }
```

---

## 四、新增节点类型（仅用于统一形态）

| type       | 用途           | 字段           |
|------------|----------------|----------------|
| **text**   | 纯文本（替代裸字符串） | `type`, `content` (string) |
| **tableRow** | 表格行容器（替代 rows[i]） | `type`, `children` (单元格节点数组) |

渲染规则：

- **text**：直接输出 `content` 的文本（可包在 span 或由 list/table 决定是否包在 li/td 内）。
- **tableRow**：不渲染自身 DOM，仅按顺序渲染其 `children`，每个子节点对应一个 `<td>`；由父级 `table` 负责 `<tr>` 包裹。

---

## 五、与现有 JSON 的对照

| 现有形态 | 统一协议形态 |
|----------|----------------|
| 根 `content: [...]` | 根 `children: [...]` |
| section `content: [...]` | section `children: [...]` |
| list `items: ["a", { type: 'paragraph', ... }]` | list `children: [{ type: 'text', content: 'a' }, { type: 'paragraph', ... }]` |
| table `rows: [[ "a", "b" ], [ "c", { type: 'image', ... } ]]` | table `children: [ { type: 'tableRow', children: [ text, text ] }, { type: 'tableRow', children: [ text, image ] } ]` |
| note `content: "..."` 或 `content: { type: 'paragraph', ... }` | note `children: [{ type: 'text', content: '...' }]` 或 `children: [{ type: 'paragraph', ... }]` |

叶子节点（heading、paragraph、image、link 等）字段不变，仅不再使用「容器内混用字符串」的写法，全部改为节点。

---

## 六、自递归渲染的用法

在采用本协议后，渲染器可统一实现：

1. 根据当前节点 `config.type` 解析出要渲染的组件（含 list、table、section、note、tableRow、text）。
2. 若该类型在协议中有 **`children`**，则对 `config.children` 做一次遍历，对每一项递归调用同一渲染器；**不再**按 type 分支「从 content/items/rows 取子」。
3. 「子节点包在什么结构里」（`<li>`、`<td>`、`<tr>`、折叠块）由**该节点的组件**在模板中决定：组件内部仍可 `v-for="child in config.children"` 并包一层 DOM，再在内部对每项 `child` 调用统一的子节点渲染器。

这样，**「谁有子、子在哪」** 的答案统一为「看 `children` 是否存在且为非空数组」；**「子外面包什么」** 仍由各容器组件负责，不进入渲染器的分支逻辑。

---

## 七、迁移与兼容策略（可选）

- **新配置**：直接按本协议书写，根用 `children`，容器用 `children` + 必要时 `text`/`tableRow`。
- **旧配置**：可在加载后经一步 **normalize** 转为统一形再交给渲染器：把根 `content` 映射为 `children`；把 section `content` 映射为 `children`；把 list `items` 中字符串转为 `{ type: 'text', content }`、对象保留；把 table `rows` 转为 `children` of `tableRow`；把 note 的 `content` 转为 0 或 1 个元素的 `children`。这样现有 JSON 文件无需改即可在内存中变为统一形式，渲染器只认统一形式即可。
- **校验**：若支持本协议，校验逻辑可统一为「每个节点有 type」「若存在 children 则必为节点数组」；再按 type 校验 type 专属必填字段（如 heading 的 level、list 的 style 等）。

---

## 八、小结

| 要点 | 说明 |
|------|------|
| 统一子节点字段 | 一律使用 `children`，类型为「节点对象数组」 |
| 无裸字符串子项 | 纯文本用 `type: 'text'`, `content: string` |
| 表格二维结构 | 用 `children`(行) + `tableRow` 的 `children`(单元格) 表达，表头仍为 `headers` |
| note 单子 | 用 `children` 长度为 0 或 1 的数组 |
| 新增类型 | `text`、`tableRow`，仅用于统一形态，语义与现有一致 |
| 功能与语义 | 与现有 JSON 支持的能力、样式、交互保持一致，仅数据形状统一便于自递归 |

按此协议，可在不损失现有功能与语义的前提下，用统一形式的配置支持「类似 Vue 虚拟 DOM 树」的自递归渲染。
