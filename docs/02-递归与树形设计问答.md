# 递归与树形设计 — 问答整理

本文整理「为什么不在 ComponentRenderer 里自递归」「Vue 也是递归渲染」「JSON 配置的树形」等相关问答。设计理由的完整展开见 [01-为什么递归在容器组件而非ComponentRenderer](./01-为什么递归在容器组件而非ComponentRenderer.md)。

---

## Q1：为什么不能自递归？不能自递归，然后根据类型渲染么？

**可以**在 ComponentRenderer 里做自递归，并「按 type 选组件、对子节点再调一次 ComponentRenderer」。递归形式是统一的。

难点在于：**「子节点从哪来」必须按 type 来写**，没法用一套逻辑搞定：

- `type === 'section'` → 子节点在 `config.content`（数组）
- `type === 'list'` → 子节点在 `config.items`，且每一项可能是**字符串或对象**，要分支处理
- `type === 'table'` → 子节点在 `config.rows` 里，是**二维**的（行 → 单元格）
- `type === 'note'` → 只有一个 `config.content`，是**单个**值，不是数组

所以即便在 ComponentRenderer 里自递归，也至少要维护「type → 如何取子节点」的逻辑（例如 `getChildren(config)` 里按 type 分支），和现在写在各自容器里的逻辑是等价的，只是从分散变成集中。

再加上**子节点还要包在不同结构里**（list 包 `<li>`、table 包 `<td>`、section 包折叠 div 等），若这些也放进 ComponentRenderer，就要再按 type 写「怎么包」，渲染器会变成既管 type 分发又管所有容器结构的「上帝组件」。

因此：不是技术上不能自递归，而是**自递归时「取子 + 包裹」仍要按类型写**；把这两块留在各自容器里，职责更清晰，扩展时也不用改 ComponentRenderer。详见 [01-为什么递归在容器组件而非ComponentRenderer](./01-为什么递归在容器组件而非ComponentRenderer.md)。

---

## Q2：Vue 不就是自递归渲染虚拟 DOM 树么？

是的，Vue 会递归地渲染整棵组件/虚拟 DOM 树。区别在于：**这棵树的形状是谁、在哪儿定下来的**。

**Vue 的递归**：树的形状是你在**模板里写死的**。例如 `<List><ListItem v-for="..." /></List>` 已经决定了「List 下面是一串 ListItem、每个包在 `<li>` 里」。运行时 Vue 只是沿着这棵**已经定好的树**从根走到叶子，对每个节点执行创建/更新。树形是事先在模板里定好的，不需要根据数据去「推断」谁是谁的子、子要包在什么里。

**我们这边**：手里只有 **JSON 配置**，没有事先写好的组件树。要得到一棵「组件树」，必须先**解释**配置：这个节点的子在哪？（content / items / rows / 单值 content）这些子外面包什么？（`<li>` / `<td>` / 折叠 div）这一步是**按 type 各不相同的**。所以多出来的不是「递归」本身，而是**从 config 里把树形解释出来**——解释逻辑按 type 不同，放在各容器里更自然。

总结：Vue 的递归是「对一棵已经定好的树做遍历」；我们还要先**根据 config 把这棵树造出来**，造树这一步由各容器在做。

---

## Q3：也就是说，现在我的 JSON 配置没有明确的树形？

不完全是。**JSON 本身是树形的**（有嵌套），只是**没有用统一的「树形约定」**。

**树形是有的**：

- 根级有 `content` 数组 → 第一层子节点
- `section` 里有 `content` 数组 → 该 section 的子节点
- `list` 的 `items` 里可以有对象 → 列表项里的子块
- `table` 的 `rows` 里单元格可以是对象 → 单元格里的子块
- `note` 的 `content` 可以是对象 → 唯一一个子块

从根到叶子是一层一层嵌套的，**结构上就是一棵树**。

==**「不明确」指的是**：子节点在哪个字段、长什么样，**没有统一成一种 schema**。== 若「明确」是指每个节点都用同一个字段表示子节点（例如一律 `children: [...]`），那当前配置不是这种约定：

- section 的子在 `content`
- list 的子在 `items`（且项可能是字符串或对象）
- table 的子在 `rows` 里，还是二维的
- note 的「子」是单个 `content`，不是数组

所以：树是有的，但「子节点在哪个字段、形态如何」按 type 不同，要按类型解读。这也是为什么「从 config 里把树解释出来」的逻辑放在各容器里——每个容器知道自己的子在哪、怎么包。

---

## 四、所以不能用自递归的核心就是，当前 JSON 没有统一子节点形式？

**结论**：是的，核心原因就是当前 JSON 没有统一的子节点形式；在此基础上，若在渲染器里自递归，就要把「按 type 取子 + 按 type 包裹」都塞进渲染器，所以我们选择把递归放在容器里。

- **没有统一形式**：子节点有的在 `content`，有的在 `items`，有的在 `rows`（二维），有的是单值 `content`，字段和形态按 type 各异。
- **带来的结果**：在 ComponentRenderer 里自递归的话，就不得不在那里写满「按 type 取子」和「按 type 包裹」的逻辑，渲染器会变成既管分发又管所有容器结构的上帝组件。
- **因此**：我们**选择**不在 ComponentRenderer 里自递归，把「取子 + 包裹」留在各容器里；不是「技术上做不到自递归」，而是「一旦自递归，就要在渲染器里集中处理不统一的约定」，所以不这么设计。

一句话：没有统一子节点形式，是「不在渲染器里自递归」的核心原因；自递归本身可行，但会把所有按 type 的差异都推进渲染器，所以递归放在容器里。
